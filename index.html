<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>fhEVM Encrypted Counter — Demo (Sepolia)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- ethers v6 (UMD build) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" defer></script>
</head>
<body style="font-family:system-ui;max-width:720px;margin:32px auto;padding:0 16px">
  <h1>fhEVM Encrypted Counter (Sepolia)</h1>

  <p>
    <button id="connect">Connect MetaMask</button>
    <span id="account" style="margin-left:8px;color:#555"></span>
  </p>

  <p>
    <label>Number (uint32): <input id="value" type="number" min="0" max="4294967295" value="5"></label>
    <button id="btnAdd">➕ Add (encrypted)</button>
  </p>

  <p>
    <button id="btnShow">🔎 Show via HTTP Public Decrypt</button>
    <button id="btnReveal">🪄 On-chain Reveal (Oracle)</button>
  </p>

  <pre id="log" style="background:#f7f7f8;border:1px solid #eee;padding:12px;min-height:180px;white-space:pre-wrap"></pre>

  <script type="module">
    // Official Relayer SDK (ESM CDN). Docs: Web applications guide.
    // It bundles WASM + workers and exposes initSDK/createInstance/SepoliaConfig.
    import { initSDK, createInstance, SepoliaConfig }
      from "https://cdn.zama.ai/relayer-sdk-js/0.1.0-9/relayer-sdk-js.js"; // docs show this path :contentReference[oaicite:1]{index=1}

    // Your deployed contract
    const CONTRACT_ADDRESS = "0xC5B8f66e56D41d067D88C06413AbCe7b99727E44";

    // ABI note:
    // externalEuint32 is encoded as bytes32 in the ABI, so we declare bytes32 here.
    const ABI = [
      "function add(bytes32 encryptedAmount, bytes inputProof) external",
      "function getEncryptedHandle() view returns (bytes32)",
      "function requestReveal() external",
      "function lastPlain() view returns (uint32)"
    ];

    const $ = (id) => document.getElementById(id);
    const log = (...args) => { const el = $("log"); el.textContent += args.join(" ") + "\n"; el.scrollTop = el.scrollHeight; };

    let instance;   // Relayer SDK instance
    let signer, account;
    let contract;   // ethers.Contract

    // Connect MetaMask and initialize the Relayer SDK (Sepolia)
    async function connect() {
      if (!window.ethereum) { alert("MetaMask required"); return; }
      await window.ethereum.request({ method: "eth_requestAccounts" });

      // ethers v6 BrowserProvider + signer
      const provider = new ethers.BrowserProvider(window.ethereum);
      signer = await provider.getSigner();
      account = await signer.getAddress();
      $("account").textContent = account;

      // Load WASM and create fhEVM instance for Sepolia.
      // SepoliaConfig ships with chainId/gatewayChainId/relayerUrl maintained by Zama.
      await initSDK(); // must be called once before using the SDK
      const config = { ...SepoliaConfig, network: window.ethereum }; // use MetaMask network
      instance = await createInstance(config); // documented init flow :contentReference[oaicite:2]{index=2}

      // Initialize contract binding
      contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

      log("✅ Connected:", account);
    }

    // Encrypt a uint32 and call add()
    async function addEncrypted() {
      try {
        const v = BigInt($("value").value);
        log("Step 1: encrypting", v.toString());

        // Register + encrypt input for this contract and user
        const buffer = instance.createEncryptedInput(CONTRACT_ADDRESS, account);
        buffer.add32(v); // euint32
        const ciphertexts = await buffer.encrypt(); // -> { handles: [...], inputProof }

        log(" → handle:", ciphertexts.handles[0]);

        log("Step 2: calling add(...)");
        const tx = await contract.add(ciphertexts.handles[0], ciphertexts.inputProof);
        log(" → tx:", tx.hash);
        const rc = await tx.wait();
        log(" → mined in block", rc.blockNumber);
      } catch (e) {
        console.error(e);
        log("❌ add() error:", e?.message || e);
      }
    }

    // Show plaintext via HTTP public decryption (off-chain)
    async function showValueHttp() {
      try {
        log("Getting handle from contract...");
        const handle = await contract.getEncryptedHandle();
        log(" handle:", handle);
        log("Calling publicDecrypt via Relayer...");
        const values = await instance.publicDecrypt([handle]); // returns a map: { handleHex: value }
        log(" → plaintext:", values[handle]);
      } catch (e) {
        console.error(e);
        log("❌ publicDecrypt error:", e?.message || e);
      }
    }

    // Trigger on-chain reveal (asynchronous Oracle path)
    async function revealOnChain() {
      try {
        log("Sending on-chain requestReveal()...");
        const tx = await contract.requestReveal();
        log(" → tx:", tx.hash);
        await tx.wait();

        // Poll lastPlain after a short delay (oracle response is asynchronous)
        setTimeout(async () => {
          try {
            const plain = await contract.lastPlain();
            log(" → lastPlain =", plain.toString());
          } catch (e) {
            log(" (Oracle might not have responded yet, try again shortly)");
          }
        }, 8000);
      } catch (e) {
        console.error(e);
        log("❌ requestReveal error:", e?.message || e);
      }
    }

    $("connect").onclick = connect;
    $("btnAdd").onclick = addEncrypted;
    $("btnShow").onclick = showValueHttp;
    $("btnReveal").onclick = revealOnChain;
  </script>
</body>
</html>
