<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>fhEVM Encrypted Counter ‚Äî Demo (Sepolia)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- ethers v6 (UMD build) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" defer></script>
</head>
<body style="font-family:system-ui;max-width:720px;margin:32px auto;padding:0 16px">
  <h1>fhEVM Encrypted Counter (Sepolia)</h1>

  <p>
    <button id="connect">Connect MetaMask</button>
    <span id="account" style="margin-left:8px;color:#555"></span>
  </p>

  <p>
    <label>Number (uint32): <input id="value" type="number" min="0" max="4294967295" value="5"></label>
    <button id="btnAdd">‚ûï Add (encrypted)</button>
  </p>

  <p>
    <button id="btnShow">üîé Show via HTTP Public Decrypt</button>
    <button id="btnReveal">ü™Ñ On-chain Reveal (Oracle)</button>
  </p>

  <pre id="log" style="background:#f7f7f8;border:1px solid #eee;padding:12px;min-height:180px;white-space:pre-wrap"></pre>

<script type="module">
  // Relayer SDK (ESM CDN)
  import { initSDK, createInstance, SepoliaConfig }
    from "https://cdn.zama.ai/relayer-sdk-js/0.1.0-9/relayer-sdk-js.js";

  // ethers v6 is loaded by the UMD <script> in <head>
  const CONTRACT_ADDRESS = "0xC5B8f66e56D41d067D88C06413AbCe7b99727E44";
  const ABI = [
    "function add(bytes32 encryptedAmount, bytes inputProof) external",
    "function getEncryptedHandle() view returns (bytes32)",
    "function requestReveal() external",
    "function lastPlain() view returns (uint32)"
  ];

  const $ = (id) => document.getElementById(id);
  const log = (...args) => { const el = $("log"); el.textContent += args.join(" ") + "\n"; el.scrollTop = el.scrollHeight; };

  let connecting = false;
  let instance = null;   // Relayer SDK instance
  let signer = null, account = null;
  let contract = null;
  let initialized = false;

  // Disable action buttons until connected
  const setUiEnabled = (on) => {
    $("btnAdd").disabled   = !on;
    $("btnShow").disabled  = !on;
    $("btnReveal").disabled= !on;
  };
  setUiEnabled(false); // start disabled

  async function connect() {
    if (initialized || connecting) return; // prevent re-entry
    connecting = true;

    try {
      if (!window.ethereum) { alert("MetaMask required"); return; }

      // 1) Request accounts and set up signer
      await window.ethereum.request({ method: "eth_requestAccounts" });
      const provider = new ethers.BrowserProvider(window.ethereum);
      signer  = await provider.getSigner();
      account = await signer.getAddress();
      $("account").textContent = account;

      // 2) Init WASM and create SDK instance
      await initSDK(); // must be called before createInstance
      const config = { ...SepoliaConfig, network: window.ethereum };
      instance = await createInstance(config);

      // 3) Bind contract
      contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

      initialized = true;
      setUiEnabled(true);
      log("‚úÖ Connected:", account);
    } catch (e) {
      console.error(e);
      log("‚ùå connect() error:", e?.message || e);
    } finally {
      connecting = false;
    }
  }

  // Helper to ensure we‚Äôre connected before any action
  async function ensureConnected() {
    if (!initialized) {
      await connect();
      if (!initialized) throw new Error("Not connected");
    }
  }

  // Encrypt a uint32 and call add()
  async function addEncrypted() {
    try {
      await ensureConnected(); // lazy connect if user skipped it

      const v = BigInt($("value").value);
      log("Step 1: encrypting", v.toString());

      // Register + encrypt input for this contract and user
      const buffer = instance.createEncryptedInput(CONTRACT_ADDRESS, account);
      buffer.add32(v); // euint32
      const ciphertexts = await buffer.encrypt(); // { handles: [...], inputProof }
      log(" ‚Üí handle:", ciphertexts.handles[0]);

      log("Step 2: calling add(...)");
      const tx = await contract.add(ciphertexts.handles[0], ciphertexts.inputProof);
      log(" ‚Üí tx:", tx.hash);
      const rc = await tx.wait();
      log(" ‚Üí mined in block", rc.blockNumber);
    } catch (e) {
      console.error(e);
      log("‚ùå add() error:", e?.message || e);
    }
  }

  // Show plaintext via HTTP public decryption (off-chain)
  async function showValueHttp() {
    try {
      await ensureConnected();

      log("Getting handle from contract...");
      const handle = await contract.getEncryptedHandle();
      log(" handle:", handle);

      log("Calling publicDecrypt via Relayer...");
      const values = await instance.publicDecrypt([handle]); // { [handleHex]: value }
      log(" ‚Üí plaintext:", values[handle]);
    } catch (e) {
      console.error(e);
      log("‚ùå publicDecrypt error:", e?.message || e);
    }
  }

  // Trigger on-chain reveal (asynchronous Oracle path)
  async function revealOnChain() {
    try {
      await ensureConnected();

      log("Sending on-chain requestReveal()...");
      const tx = await contract.requestReveal();
      log(" ‚Üí tx:", tx.hash);
      await tx.wait();

      // Poll lastPlain after a short delay (oracle response is asynchronous)
      setTimeout(async () => {
        try {
          const plain = await contract.lastPlain();
          log(" ‚Üí lastPlain =", plain.toString());
        } catch (e) {
          log(" (Oracle might not have responded yet, try again shortly)");
        }
      }, 8000);
    } catch (e) {
      console.error(e);
      log("‚ùå requestReveal error:", e?.message || e);
    }
  }

  // Wire buttons
  $("connect").onclick  = connect;
  $("btnAdd").onclick   = addEncrypted;
  $("btnShow").onclick  = showValueHttp;
  $("btnReveal").onclick= revealOnChain;

  // Optional: auto-connect on page load (comment out if you prefer manual)
  // await connect();
</script>
</body>
</html>
